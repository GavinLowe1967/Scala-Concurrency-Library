Test buffered channels -- done 

Use buffered channels in Trapezium. -- done

Examples from Interacting Peers. -- done

Sorting practical

Dining Philosophers practical: two parts done; need to do version with timeout.

Client-server examples -- done

In linearizability testing and Log, check operating system if tsQueue

Catch errors in threads -- done

-----------------

Alternation:
- Extend to buffered channels -- done

- Extend to sending branches -- done

- Examples with clients and servers -- done 

- In SyncChan, have send wait only if receiversWaiting = 0 -- unsound! 

- Implement timed sends/receives in channels -- done

- When repeating, start registering from where the previous round finished. --
  done

- In channels, would it be better for sender to signal on slotEmptied?

- Do final version of Dining Philosophers

- Do rest of datatypes

- Think about restrictions on usage: I think we can't have both ends of a
  SyncChan in alts, but it's ok with a BuffChan.  Do run-time tests for
  enforcement.

- Pass channels by name, not value. 

---------------


Calls to maybeReceive, portClosed use lock and block while registering except
for calls concerning earlier iteration.  Main thread notifies them.  Main
thread obtains lock (a) to set registering = true; (b) to set registering =
false and notifyAll (publishes enabled, etc.), and then to wait for signal. 

Is it possible to implement SyncChan with less waiting?  Switch on who is
there first.  Maybe separate locks for sending and receiving. 

Extend channels with timed operations.

Trim linearizability tester? 
